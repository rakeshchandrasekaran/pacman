<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Pacman</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: white;
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            flex-direction: column;
            padding: 20px;
        }
        
        h1 {
            color: #c41e3a;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .game-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        #gameCanvas {
            border: 3px solid #c41e3a;
            display: block;
            background: white;
        }
        
        .info-panel {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .score {
            color: #165b33;
        }
        
        .lives {
            color: #c41e3a;
        }
        
        .controls {
            margin-top: 15px;
            text-align: center;
            color: #333;
        }
        
        .game-over {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 8px 40px rgba(0,0,0,0.3);
            text-align: center;
            z-index: 1000;
        }
        
        .game-over h2 {
            color: #c41e3a;
            font-size: 2em;
            margin-bottom: 20px;
        }
        
        .game-over button {
            background: #165b33;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        .game-over button:hover {
            background: #0f4a28;
        }
    </style>
</head>
<body>
    <h1>üéÑ Christmas Pacman üéÖ</h1>
    <div class="game-container">
        <canvas id="gameCanvas" width="560" height="560"></canvas>
        <div class="info-panel">
            <div class="score">Score: <span id="score">0</span></div>
            <div class="lives">Lives: <span id="lives">3</span></div>
        </div>
        <div class="controls">
            Use Arrow Keys to Move | Collect all presents! üéÅ
        </div>
    </div>
    
    <div class="game-over" id="gameOver">
        <h2 id="gameOverText">Game Over!</h2>
        <p id="finalScore"></p>
        <button onclick="restartGame()">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const livesElement = document.getElementById('lives');
        const gameOverElement = document.getElementById('gameOver');
        
        // Game constants
        const TILE_SIZE = 20;
        const GRID_WIDTH = 28;
        const GRID_HEIGHT = 28;
        
        // Game state
        let score = 0;
        let lives = 3;
        let gameRunning = true;
        let powerUpActive = false;
        let powerUpTimer = 0;
        
        // Maze layout (1 = wall, 0 = path, 2 = dot, 3 = power pellet)
        const maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
            [1,3,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,3,1],
            [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
            [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],
            [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],
            [1,1,1,1,1,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,1,1,1,1],
            [1,1,1,1,1,1,2,1,1,0,1,1,1,0,0,1,1,1,0,1,1,2,1,1,1,1,1,1],
            [1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1],
            [0,0,0,0,0,0,2,0,0,0,1,0,0,0,0,0,0,1,0,0,0,2,0,0,0,0,0,0],
            [1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1],
            [1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1],
            [1,1,1,1,1,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,1,1,1,1],
            [1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1],
            [1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
            [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
            [1,3,2,2,1,1,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,1,1,2,2,3,1],
            [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
            [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
            [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        
        // Player (Santa)
        const player = {
            x: 14,
            y: 23,
            direction: 0,
            nextDirection: 0,
            mouthOpen: 0
        };
        
        // Ghosts (Snowmen)
        const ghosts = [
            { x: 12, y: 11, color: '#c41e3a', direction: 0, startX: 12, startY: 11 },
            { x: 13, y: 14, color: '#165b33', direction: 0, startX: 13, startY: 14 },
            { x: 14, y: 14, color: '#0066cc', direction: 0, startX: 14, startY: 14 },
            { x: 15, y: 11, color: '#ff9900', direction: 0, startX: 15, startY: 11 }
        ];
        
        // Direction vectors
        const directions = [
            { x: 0, y: 0 },   // 0: stopped
            { x: 0, y: -1 },  // 1: up
            { x: 1, y: 0 },   // 2: right
            { x: 0, y: 1 },   // 3: down
            { x: -1, y: 0 }   // 4: left
        ];
        
        // Draw maze
        function drawMaze() {
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const tile = maze[y][x];
                    const px = x * TILE_SIZE;
                    const py = y * TILE_SIZE;
                    
                    if (tile === 1) {
                        // Wall (Christmas tree green)
                        ctx.fillStyle = '#165b33';
                        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                        ctx.strokeStyle = '#0f4a28';
                        ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);
                    } else if (tile === 2) {
                        // Present (dot)
                        ctx.fillStyle = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, 3, 0, Math.PI * 2);
                        ctx.fill();
                        // Add bow
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(px + TILE_SIZE/2 - 1, py + TILE_SIZE/2 - 1, 2, 2);
                    } else if (tile === 3) {
                        // Big present (power pellet)
                        ctx.fillStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(px + TILE_SIZE/2 - 2, py + TILE_SIZE/2 - 2, 4, 4);
                    }
                }
            }
        }
        
        // Draw Santa
        function drawPlayer() {
            const px = player.x * TILE_SIZE + TILE_SIZE/2;
            const py = player.y * TILE_SIZE + TILE_SIZE/2;
            const radius = TILE_SIZE/2 - 2;
            
            // Body (red)
            ctx.fillStyle = '#c41e3a';
            ctx.beginPath();
            ctx.arc(px, py, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Hat
            ctx.fillStyle = '#c41e3a';
            ctx.beginPath();
            ctx.arc(px - 3, py - 3, radius/2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(px - 3, py - 3, radius/4, 0, Math.PI * 2);
            ctx.fill();
            
            // Mouth (animated)
            if (player.direction !== 0) {
                const angle = (player.direction - 1) * Math.PI / 2;
                const mouthSize = player.mouthOpen * Math.PI / 4;
                
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.arc(px, py, radius, angle - mouthSize, angle + mouthSize);
                ctx.closePath();
                ctx.fill();
            }
        }
        
        // Draw ghost (snowman)
        function drawGhost(ghost) {
            const px = ghost.x * TILE_SIZE + TILE_SIZE/2;
            const py = ghost.y * TILE_SIZE + TILE_SIZE/2;
            const radius = TILE_SIZE/2 - 2;
            
            if (powerUpActive) {
                // Scared mode (blue)
                ctx.fillStyle = '#4444ff';
            } else {
                ctx.fillStyle = ghost.color;
            }
            
            // Body
            ctx.beginPath();
            ctx.arc(px, py, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(px - 3, py - 2, 2, 0, Math.PI * 2);
            ctx.arc(px + 3, py - 2, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Carrot nose
            ctx.fillStyle = '#ff6600';
            ctx.beginPath();
            ctx.moveTo(px, py);
            ctx.lineTo(px + 5, py + 2);
            ctx.lineTo(px, py + 1);
            ctx.closePath();
            ctx.fill();
            
            // Buttons
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(px, py + 5, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Check if move is valid
        function isValidMove(x, y) {
            if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT) {
                return false;
            }
            return maze[Math.floor(y)][Math.floor(x)] !== 1;
        }
        
        // Move player
        function movePlayer() {
            if (player.direction === 0) return;
            
            const dir = directions[player.direction];
            const newX = player.x + dir.x * 0.15;
            const newY = player.y + dir.y * 0.15;
            
            if (isValidMove(newX, newY)) {
                player.x = newX;
                player.y = newY;
                
                // Wrap around
                if (player.x < 0) player.x = GRID_WIDTH - 1;
                if (player.x >= GRID_WIDTH) player.x = 0;
                
                // Check for dots/presents
                const gridX = Math.floor(player.x);
                const gridY = Math.floor(player.y);
                
                if (maze[gridY][gridX] === 2) {
                    maze[gridY][gridX] = 0;
                    score += 10;
                    scoreElement.textContent = score;
                    checkWin();
                } else if (maze[gridY][gridX] === 3) {
                    maze[gridY][gridX] = 0;
                    score += 50;
                    scoreElement.textContent = score;
                    powerUpActive = true;
                    powerUpTimer = 200;
                    checkWin();
                }
                
                // Animate mouth
                player.mouthOpen = (player.mouthOpen + 0.1) % 1;
            } else {
                player.direction = 0;
            }
        }
        
        // Move ghosts
        function moveGhosts() {
            ghosts.forEach(ghost => {
                // Simple AI: random direction with preference toward player
                if (Math.random() < 0.02 || !isValidMove(ghost.x + directions[ghost.direction].x * 0.1, 
                                                          ghost.y + directions[ghost.direction].y * 0.1)) {
                    const possibleDirs = [1, 2, 3, 4].filter(dir => {
                        const newX = ghost.x + directions[dir].x * 0.1;
                        const newY = ghost.y + directions[dir].y * 0.1;
                        return isValidMove(newX, newY);
                    });
                    
                    if (possibleDirs.length > 0) {
                        if (!powerUpActive && Math.random() < 0.3) {
                            // Chase player
                            const distances = possibleDirs.map(dir => {
                                const newX = ghost.x + directions[dir].x;
                                const newY = ghost.y + directions[dir].y;
                                return Math.abs(newX - player.x) + Math.abs(newY - player.y);
                            });
                            ghost.direction = possibleDirs[distances.indexOf(Math.min(...distances))];
                        } else {
                            ghost.direction = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                        }
                    }
                }
                
                const dir = directions[ghost.direction];
                ghost.x += dir.x * 0.08;
                ghost.y += dir.y * 0.08;
                
                // Wrap around
                if (ghost.x < 0) ghost.x = GRID_WIDTH - 1;
                if (ghost.x >= GRID_WIDTH) ghost.x = 0;
            });
        }
        
        // Check collision with ghosts
        function checkCollisions() {
            ghosts.forEach(ghost => {
                const dist = Math.sqrt(Math.pow(ghost.x - player.x, 2) + Math.pow(ghost.y - player.y, 2));
                if (dist < 0.5) {
                    if (powerUpActive) {
                        // Eat ghost
                        score += 200;
                        scoreElement.textContent = score;
                        ghost.x = ghost.startX;
                        ghost.y = ghost.startY;
                    } else {
                        // Lose life
                        lives--;
                        livesElement.textContent = lives;
                        player.x = 14;
                        player.y = 23;
                        player.direction = 0;
                        
                        if (lives <= 0) {
                            gameOver(false);
                        }
                    }
                }
            });
        }
        
        // Check win condition
        function checkWin() {
            let dotsLeft = 0;
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (maze[y][x] === 2 || maze[y][x] === 3) {
                        dotsLeft++;
                    }
                }
            }
            if (dotsLeft === 0) {
                gameOver(true);
            }
        }
        
        // Game over
        function gameOver(won) {
            gameRunning = false;
            const gameOverText = document.getElementById('gameOverText');
            const finalScore = document.getElementById('finalScore');
            
            if (won) {
                gameOverText.textContent = 'üéâ You Won! üéâ';
                gameOverText.style.color = '#165b33';
            } else {
                gameOverText.textContent = '‚òÉÔ∏è Game Over! ‚òÉÔ∏è';
                gameOverText.style.color = '#c41e3a';
            }
            
            finalScore.textContent = `Final Score: ${score}`;
            gameOverElement.style.display = 'block';
        }
        
        // Restart game
        function restartGame() {
            location.reload();
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp': player.nextDirection = 1; e.preventDefault(); break;
                case 'ArrowRight': player.nextDirection = 2; e.preventDefault(); break;
                case 'ArrowDown': player.nextDirection = 3; e.preventDefault(); break;
                case 'ArrowLeft': player.nextDirection = 4; e.preventDefault(); break;
            }
            
            // Try to change direction
            if (player.nextDirection !== 0) {
                const dir = directions[player.nextDirection];
                if (isValidMove(player.x + dir.x * 0.1, player.y + dir.y * 0.1)) {
                    player.direction = player.nextDirection;
                }
            }
        });
        
        // Game loop
        function gameLoop() {
            if (!gameRunning) return;
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawMaze();
            movePlayer();
            moveGhosts();
            checkCollisions();
            
            ghosts.forEach(drawGhost);
            drawPlayer();
            
            // Power up timer
            if (powerUpActive) {
                powerUpTimer--;
                if (powerUpTimer <= 0) {
                    powerUpActive = false;
                }
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Start game
        gameLoop();
    </script>
</body>
</html>
